#!/usr/bin/env python
# coding: utf-8

# # File Operations

# ## read graphs generated by our model and facebook file into networkx graphs

# In[1]:


import networkx as nx
import matplotlib.pyplot as plt

def ReadGraph(filename):
    f= open(filename, "r")
    str = f.readline();
    
    while str=="\n":
        str=f.readline();
        
    n_nodes = int(str.split(" ")[0])
    n_edges = int(str.split(" ")[1])
    g=nx.Graph();
    
    for j in range(n_edges):
        str=f.readline()
      
        source = str[1:-2].split(" : ")[0];
        target = str[1:-2].split(" : ")[1];
        
        source = source[1:]
        target = target[1:]
        if not g.has_node(source):
            g.add_node(source)
        if not g.has_node(target):
            g.add_node(target)
        g.add_edge(source, target)
        
    return g

def readFacebookGraph(filename):
    f= open(filename, "r")
    
    g=nx.Graph()
    
    for line in f:
        source, target = line.rstrip().split(" ")
        
        if g.has_node(source)==False:
            g.add_node(source)
        if g.has_node(target) == False:
            g.add_node(target)
            
        g.add_edge(source, target)
        
    return g

    return g

def readEpinionsGraph(filename):
    f= open(filename, "r")
    
    g=nx.DiGraph()
    for line in f:
        fds = line.strip().split(" ")
        source, target = fds[0:2]
        
        if g.has_node(source)==False:
            g.add_node(source)
        if g.has_node(target) == False:
            g.add_node(target)
        if g.has_edge(source, target):
            print("{},{} already existed\n".format(source, target))
        g.add_edge(source, target)
    g = g.to_undirected()
    return g


# ## read graphs into SnapGrpahs

# In[1]:


def readGraphInSnap(filename):
    g = snap.TUNGraph.New()
    f = open(filename, 'r')
    num_nodes, a,b = f.readline().rstrip().split(" ")
    for line in f:
        source, target = line[1:-2].split(" : ")
        source = int(source[1:])
        target = int(target[1:])
        if not g.IsNode(source):
            g.AddNode(source)
        if not g.IsNode(target):
            g.AddNode(target)
        g.AddEdge(source, target)
    return g
        
def readGraphEpinionsInSnap(filename):
    f= open(filename, "r")
    
    g = snap.TUNGraph.New()
    
    for line in f:
        fds =line.strip().split(" ")
        source, target = fds[0:2]
        source = int(source)
        target = int(target)
        if not g.IsNode(source):
            g.AddNode(source)
        if not g.IsNode(target):
            g.AddNode(target)
        g.AddEdge(source, target)
    
    return g

def readGraphFacebookInSnap(filename):
    f= open(filename, "r")
    
    g = snap.TUNGraph.New()
    
    for line in f:
        source, target = line.rstrip().split(" ")
        source = int(source)
        target = int(target)
        if not g.IsNode(source):
            g.AddNode(source)
        if not g.IsNode(target):
            g.AddNode(target)
        g.AddEdge(source, target)
       
    return g


# # Operation on communities

# In[4]:


import pandas as pd
import numpy as np
def get_coms_from_partition(partition):

    coms = dict([])
    for comm in set(partition.values()):
        coms[comm] = np.array([node for node in partition.keys() if partition[node] == comm])
    return coms


def get_com_ground_truth_from_circlefile(filename):

    com_gr = dict([])

    for i in range(9):
        s = pd.read_csv(filename, sep="\s+", header =None, index_col=0, nrows=1, skiprows=i)
        com_gr[i] = s.iloc[0].tolist()
    return com_gr

def get_com_ground_truth_from_circlefile_txt(filename):
    com_gr = dict([])
    
    fin = open(filename, 'r')
    
    com_index = 0
    for line in fin:
        fds = line.strip().split("\t")
        com_gr[com_index] = fds[1:]
        com_index += 1
    return com_gr
        


def f1_score(com1, com2):
    intersec = list(set(com1).intersection(set(com2)))
    prec = len(intersec)*1.0/len(com1)
    recall = len(intersec)*1.0/len(com2)
    if prec==0.:
        return 0
    return 2*prec*recall/(prec+recall)


def cal_final_f1(coms, com_gr, threshold = 100):
    score_louvain = dict([])
    for i in coms.keys():
        max_score = 0
        if (len(coms[i])<threshold):
            continue
        for j in com_gr.keys():
            if len(com_gr[j])<threshold:
                continue
            f1 = f1_score(coms[i], com_gr[j])
       
            if max_score < f1:
                max_score = f1
        score_louvain[i] = max_score
    
    score_gr = dict([])
    for i in com_gr.keys():
        if len(com_gr[i]) <threshold:
            continue
        max_score = 0
        for j in coms.keys():
            f1 = f1_score(com_gr[i], coms[j])
            if max_score < f1:
                max_score = f1
        score_gr[i] = max_score
    print(score_louvain.values())
    print(score_gr.values())
    f1 = np.average(score_louvain.values())/2 + np.average(score_gr.values())/2
    return f1


def WritePartitionToFile(partition, filename):
    f = open(filename, 'w')
    
    for comm in set(partition.values()):
        com = np.array([node for node in partition.keys() if partition[node] == comm])
        f.write("circles{}\t".format(str(comm)))
        for vertex in com:
            f.write(vertex)
            f.write("\t")
        f.write("\n")
    f.close()
    

def WritePartitionToJavaFormat(partition, filename):
    f = open(filename, 'w')
    str ='['
    for comm in set(partition.values()):
        if len(str)==1:
            str = str + "["
        else:
            str = str + ", ["
        com = np.array([node for node in partition.keys() if partition[node] == comm])
        
        for node in com:
            str = str + node +","
        str = str[:-1] +']'
    str = str + ']'
    f.write(str)
    f.close()
    

    

def readBestCut(file):
    fin = open(file, 'r')
    line = fin.readline().strip()
    line = line[1:-1]
    coms = line.split(", ")
    partition = dict([])
    c_index = 0
    for com in coms:
        vlist = com[1:-1].split(",")
        for v in vlist:
            partition[v] = c_index
        c_index += 1
    return partition

def readCesnaPartition(file):
    fin = open(file, 'r')
    com_index = 0
    coms = dict([])
    for line in fin:
        fds = line.strip().split('\t')
        coms[com_index] = np.array(fds)
        com_index += 1

    return coms


# # Operations on SnapGraph

# In[7]:


import matplotlib.pyplot as pl
import snap

def plotDegreeDistribution(snapgraph):
    CntV = snap.TIntPrV()
    snap.GetOutDegCnt(snapgraph, CntV)
    d = dict([])
    for p in CntV:
        d[p.GetVal1()] =  p.GetVal2()
    d.keys
    pl.hist(d.values(),d.keys())
    

def getDegreeDistribution(snapgraph):
    CntV = snap.TIntPrV()
    snap.GetOutDegCnt(snapgraph, CntV)
    d =dict([])
    for p in CntV:
        d[p.GetVal1()] =  p.GetVal2()
    return d

def printDegreeDistribution(snapgraph):
    CntV = snap.TIntPrV()
    snap.GetOutDegCnt(snapgraph, CntV)
    for p in CntV:
        print("degree %d: count %d"%(p.GetVal1(), p.GetVal2()))


def getLocalClusteringCoefficient(snapgraph):
    d = dict([]);
    NIdCCfH = snap.TIntFltH()
    snap.GetNodeClustCf(snapgraph, NIdCCfH)
    for item in NIdCCfH:
        d[item] = NIdCCfH[item]
    return d

def getAvgDegree(snapgraph):
    CntV = snap.TIntV()
    snap.GetDegSeqV(snapgraph, CntV)
    degList =np.array([CntV[i] for i in range(0, CntV.Len())])
    return np.average(degList)

def HellingerDistance(p1, p2):
    sum = 0 
    kset = np.union1d(list(p1.keys()), list(p2.keys()))
    a = np.array([np.power(np.sqrt(p1.get(key,0))-np.sqrt(p2.get(key, 0)),2) for key in kset])
    #sum += np.power(np.sqrt(p1[key])-np.sqrt(p2.get(key, 0)),2)
    sum = np.sum(a)
    return (1.0/np.sqrt(2))* np.sqrt(sum)


# # Data Analysis Start from here (2019/01/28)

# ## Clustering Coefficient

# In[12]:


import os
import community

def calCfWithEpsilon(dataname, folderdir, orignalGraphFile):
    
    gGen = readGraphFacebookInSnap(orignalGraphFile)
    
    cf_ori = snap.GetClustCf(gGen)
    
    elist = [2.0, 3.0, 4.0, 5.0]
    
    result = dict([])
    for e in elist:
        prefix = '{}_w_triangles_{}_final_dp_'.format(dataname, e)
        r = []
        for file in os.listdir(folderdir):
            if file.startswith(prefix):
                gGen = readGraphFacebookInSnap('{}/{}'.format(folderdir, file))
                cf = snap.GetClustCf(gGen)
                
                r.append(np.abs(cf-cf_ori)/cf_ori)
                print('{} {}'.format(e, cf))
        result[e] = r
    return result

def calCfTriCycleWithEpsilon(dataname, folderdir, orignalGraphFile):
    gGen = readGraphFacebookInSnap(orignalGraphFile)
    
    cf_ori = snap.GetClustCf(gGen)
    
    elist = [2.0, 3.0, 4.0, 5.0]
  
    result = dict([])
    for e in elist:
        prefix = '{}_TriCycle_w_triangles_{}_final_dp_'.format(dataname, e)
        r = []
        for file in os.listdir(folderdir):
            if file.startswith(prefix):
                gGen = readGraphFacebookInSnap('{}/{}'.format(folderdir, file))
                cf = snap.GetClustCf(gGen)
                
                r.append(np.abs(cf-cf_ori)/cf_ori)
                print('{} {}'.format(e, cf))
        result[e] = r
    return result

def calCfDCSBMWithEpsilon(dataname, folderdir, orignalGraphFile, threshold=100):
    gGen = readGraphFacebookInSnap(orignalGraphFile)
    
    cf_ori = snap.GetClustCf(gGen)
    
    elist = [2.0, 3.0, 4.0, 5.0]
   
    result = dict([])
    for e in elist:
        prefix = '{}_DCSBM_graph_{}_final_dp_'.format(dataname, e)
        r = []
        for file in os.listdir(folderdir):
            if file.startswith(prefix):
                gGen = readGraphFacebookInSnap('{}/{}'.format(folderdir, file))
                cf = snap.GetClustCf(gGen)
                
                r.append(np.abs(cf-cf_ori)/cf_ori)
                print('{} {}'.format(e, cf))
        result[e] = r
    return result


# ## Number of Triangles

# In[24]:


import os
import community

def calTriWithEpsilon(dataname, folderdir, orignalGraphFile):
    
    gGen = readGraphFacebookInSnap(orignalGraphFile)
    
    tri_ori = snap.GetTriads(gGen)
    
    elist = [2.0, 3.0, 4.0, 5.0]
    #if dataname == 'epinions':
    #    elist = [6.0, 7.0, 8.0, 9.0]
    result = dict([])
    for e in elist:
        prefix = '{}_w_triangles_{}_final_dp_'.format(dataname, e)
        r = []
        for file in os.listdir(folderdir):
            if file.startswith(prefix):
                gGen = readGraphFacebookInSnap('{}/{}'.format(folderdir, file))
                cf = snap.GetTriads(gGen)
                
                r.append(np.abs(cf-tri_ori)*1.0/tri_ori)
                print('{} {}'.format(e, cf))
        result[e] = r
    return result

def calTriTriCycleWithEpsilon(dataname, folderdir, orignalGraphFile):
    gGen = readGraphFacebookInSnap(orignalGraphFile)
    
    tri_ori = snap.GetTriads(gGen)
    elist = [2.0, 3.0, 4.0, 5.0]
    #if dataname == 'epinions':
     #   elist = [0.0, 6.0, 7.0, 8.0, 9.0]
    result = dict([])
    for e in elist:
        prefix = '{}_TriCycle_w_triangles_{}_final_dp_'.format(dataname, e)
        r = []
        for file in os.listdir(folderdir):
            if file.startswith(prefix):
                gGen = readGraphFacebookInSnap('{}/{}'.format(folderdir, file))
                cf = snap.GetTriads(gGen)
                
                r.append(np.abs(cf-tri_ori)*1.0/tri_ori)
                print('{} {}'.format(e, cf))
        result[e] = r
    return result

def calTriDCSBMWithEpsilon(dataname, folderdir, orignalGraphFile, threshold=100):
    gGen = readGraphFacebookInSnap(orignalGraphFile)
    
    tri_ori = snap.GetTriads(gGen)
    
    elist = [2.0, 3.0, 4.0, 5.0]
    #if dataname == 'epinions':
    #    elist = [0.0, 6.0, 7.0, 8.0, 9.0]
    result = dict([])
    for e in elist:
        prefix = '{}_DCSBM_graph_{}_final_dp_'.format(dataname, e)
        r = []
        for file in os.listdir(folderdir):
            if file.startswith(prefix):
                gGen = readGraphFacebookInSnap('{}/{}'.format(folderdir, file))
                cf = snap.GetTriads(gGen)
                
                r.append(np.abs(cf-tri_ori)*1.0/tri_ori)
                print('{} {}'.format(e, cf))
        result[e] = r
    return result


# ## Hellinger distance of degree sequence

# In[29]:


import os
import community

def calHsWithEpsilon(dataname, folderdir, orignalGraphFile):
    
    gGen = readGraphFacebookInSnap(orignalGraphFile)
    
    dgen1= getDegreeDistribution(gGen)
    dsgen1 = {key:dgen1[key]*1.0/np.sum(np.array(dgen1.values())) for key in dgen1.keys()}
    
    elist = [2.0, 3.0, 4.0, 5.0]
    #if dataname == 'epinions':
    #    elist = [6.0, 7.0, 8.0, 9.0]
    result = dict([])
    for e in elist:
        prefix = '{}_w_triangles_{}_final_dp_'.format(dataname, e)
        r = []
        for file in os.listdir(folderdir):
            if file.startswith(prefix):
                gGen = readGraphFacebookInSnap('{}/{}'.format(folderdir, file))
                dgen2= getDegreeDistribution(gGen)
                dsgen2 = {key:dgen2[key]*1.0/np.sum(np.array(dgen2.values())) for key in dgen2.keys()}
                hs = HellingerDistance(dsgen1, dsgen2)
                
                r.append(hs)
                print('{} {}'.format(e, hs))
        result[e] = r
    return result

def calHsTriCycleWithEpsilon(dataname, folderdir, orignalGraphFile):
    gGen = readGraphFacebookInSnap(orignalGraphFile)
    
    dgen1= getDegreeDistribution(gGen)
    dsgen1 = {key:dgen1[key]*1.0/np.sum(np.array(dgen1.values())) for key in dgen1.keys()}
    
    elist = [2.0, 3.0, 4.0, 5.0]
    #if dataname == 'epinions':
    #    elist = [0.0, 6.0, 7.0, 8.0, 9.0]
    result = dict([])
    for e in elist:
        prefix = '{}_TriCycle_w_triangles_{}_final_dp_'.format(dataname, e)
        r = []
        for file in os.listdir(folderdir):
            if file.startswith(prefix):
                gGen = readGraphFacebookInSnap('{}/{}'.format(folderdir, file))
                dgen2= getDegreeDistribution(gGen)
                dsgen2 = {key:dgen2[key]*1.0/np.sum(np.array(dgen2.values())) for key in dgen2.keys()}
                hs = HellingerDistance(dsgen1, dsgen2)
                
                r.append(hs)
                print('{} {}'.format(e, hs))
        result[e] = r
    return result

def calHsDCSBMWithEpsilon(dataname, folderdir, orignalGraphFile, threshold=100):
    gGen = readGraphFacebookInSnap(orignalGraphFile)
    
    dgen1= getDegreeDistribution(gGen)
    dsgen1 = {key:dgen1[key]*1.0/np.sum(np.array(dgen1.values())) for key in dgen1.keys()}
    
    
    elist = [2.0, 3.0, 4.0, 5.0]
    #if dataname == 'epinions':
    #    elist = [0.0, 6.0, 7.0, 8.0, 9.0]
    result = dict([])
    for e in elist:
        prefix = '{}_DCSBM_graph_{}_final_dp_'.format(dataname, e)
        r = []
        for file in os.listdir(folderdir):
            if file.startswith(prefix):
                gGen = readGraphFacebookInSnap('{}/{}'.format(folderdir, file))
                dgen2= getDegreeDistribution(gGen)
                dsgen2 = {key:dgen2[key]*1.0/np.sum(np.array(dgen2.values())) for key in dgen2.keys()}
                hs = HellingerDistance(dsgen1, dsgen2)
                
                r.append(hs)
                print('{} {}'.format(e, hs))
        result[e] = r
    return result


# ## Hellinger distance of local clustering coefficient sequence

# In[38]:


import os
import community

def calHlcWithEpsilon(dataname, folderdir, orignalGraphFile):
    
    gGen = readGraphFacebookInSnap(orignalGraphFile)
    
    lcoGen1 = getLocalClusteringCoefficient(gGen)
    a=plt.hist(lcoGen1.values(), bins =100)
    cs_lco_gen1 = a[0]/np.sum(a[0])
    lc1 = {i:cs_lco_gen1[i] for i in range(100)}
    
    elist = [2.0, 3.0, 4.0, 5.0]
    #if dataname == 'epinions':
    #    elist = [6.0, 7.0, 8.0, 9.0]
    result = dict([])
    for e in elist:
        prefix = '{}_w_triangles_{}_final_dp_'.format(dataname, e)
        r = []
        for file in os.listdir(folderdir):
            if file.startswith(prefix):
                gGen = readGraphFacebookInSnap('{}/{}'.format(folderdir, file))
                lcoGen2 = getLocalClusteringCoefficient(gGen)
                a=plt.hist(lcoGen2.values(), bins =100)
                cs_lco_gen2 = a[0]/np.sum(a[0])
                lc2 = {i:cs_lco_gen2[i] for i in range(100)}
                hs = HellingerDistance(lc1, lc2)
                
                r.append(hs)
                print('{} {}'.format(e, hs))
        result[e] = r
    return result

def calHlcTriCycleWithEpsilon(dataname, folderdir, orignalGraphFile):
    gGen = readGraphFacebookInSnap(orignalGraphFile)
    
    lcoGen1 = getLocalClusteringCoefficient(gGen)
    a=plt.hist(lcoGen1.values(), bins =100)
    cs_lco_gen1 = a[0]/np.sum(a[0])
    lc1 = {i:cs_lco_gen1[i] for i in range(100)}
    
    elist = [2.0, 3.0, 4.0, 5.0]
    #if dataname == 'epinions':
    #    elist = [0.0, 6.0, 7.0, 8.0, 9.0]
    result = dict([])
    for e in elist:
        prefix = '{}_TriCycle_w_triangles_{}_final_dp_'.format(dataname, e)
        r = []
        for file in os.listdir(folderdir):
            if file.startswith(prefix):
                gGen = readGraphFacebookInSnap('{}/{}'.format(folderdir, file))
                lcoGen2 = getLocalClusteringCoefficient(gGen)
                a=plt.hist(lcoGen2.values(), bins =100)
                cs_lco_gen2 = a[0]/np.sum(a[0])
                lc2 = {i:cs_lco_gen2[i] for i in range(100)}
                hs = HellingerDistance(lc1, lc2)
                
                r.append(hs)
                print('{} {}'.format(e, hs))
        result[e] = r
    return result

def calHlcDCSBMWithEpsilon(dataname, folderdir, orignalGraphFile, threshold=100):
    gGen = readGraphFacebookInSnap(orignalGraphFile)
    
    lcoGen1 = getLocalClusteringCoefficient(gGen)
    a=plt.hist(lcoGen1.values(), bins =100)
    cs_lco_gen1 = a[0]/np.sum(a[0])
    lc1 = {i:cs_lco_gen1[i] for i in range(100)}
    
    elist = [2.0, 3.0, 4.0, 5.0]
    #if dataname == 'epinions':
    #    elist = [0.0, 6.0, 7.0, 8.0, 9.0]
    result = dict([])
    for e in elist:
        prefix = '{}_DCSBM_graph_{}_final_dp_'.format(dataname, e)
        r = []
        for file in os.listdir(folderdir):
            if file.startswith(prefix):
                gGen = readGraphFacebookInSnap('{}/{}'.format(folderdir, file))
                lcoGen2 = getLocalClusteringCoefficient(gGen)
                a=plt.hist(lcoGen2.values(), bins =100)
                cs_lco_gen2 = a[0]/np.sum(a[0])
                lc2 = {i:cs_lco_gen2[i] for i in range(100)}
                hs = HellingerDistance(lc1, lc2)
                
                r.append(hs)
                print('{} {}'.format(e, hs))
        result[e] = r
    return result


# ## community F1-score louvain

# In[48]:


import os
import community

def calF1scoreWithEpsilon(dataname, folderdir, originalGraphFile, threshold =100):
    elist = [2.0, 3.0, 4.0, 5.0]
   
    gedge = readFacebookGraph(originalGraphFile)
    partition_gedge = community.best_partition(gedge)
    com_edge =  get_coms_from_partition(partition_gedge)
    
    
    result = dict([])
    for e in elist:
        prefix = '{}_w_triangles_{}_final_dp_'.format(dataname, e)
        r = []
        for file in os.listdir(folderdir):
            if file.startswith(prefix):
                gGen = readFacebookGraph('{}/{}'.format(folderdir, file))
                partition_gGen = community.best_partition(gGen)
                com_gGen = get_coms_from_partition(partition_gGen)
                f1_1 = cal_final_f1(com_edge, com_gGen,threshold)
                r.append(f1_1)
        result[e] = r
    return result

def calF1scoreTriCycleWithEpsilon(dataname, folderdir, originalGraphFile, threshold=100):
    elist = [2.0, 3.0, 4.0, 5.0]
   
    gedge = readFacebookGraph(originalGraphFile)
    partition_gedge = community.best_partition(gedge)
    com_edge =  get_coms_from_partition(partition_gedge)
    

    result = dict([])
    for e in elist:
        prefix = '{}_TriCycle_w_triangles_{}_final_dp_'.format(dataname, e)
        r = []
        for file in os.listdir(folderdir):
            if file.startswith(prefix):
                gGen = readFacebookGraph('{}/{}'.format(folderdir, file))
                partition_gGen = community.best_partition(gGen)
                com_gGen = get_coms_from_partition(partition_gGen)
                f1_1 = cal_final_f1(com_edge, com_gGen, threshold)
                r.append(f1_1)
        result[e] = r
    return result

def calF1scoreDCSBMWithEpsilon(dataname, folderdir, originalGraphFile, threshold=100):
    elist = [2.0, 3.0, 4.0, 5.0]
    
    gedge = readFacebookGraph(originalGraphFile)
    partition_gedge = community.best_partition(gedge)
    com_edge =  get_coms_from_partition(partition_gedge)
    
    result = dict([])
    for e in elist:
        prefix = '{}_DCSBM_graph_{}_final_dp_'.format(dataname, e)
        r = []
        for file in os.listdir(folderdir):
            if file.startswith(prefix):
                gGen = readFacebookGraph('{}/{}'.format(folderdir, file))
                partition_gGen = community.best_partition(gGen)
                com_gGen = get_coms_from_partition(partition_gGen)
                f1_1 = cal_final_f1(com_edge, com_gGen,threshold)
                r.append(f1_1)
        result[e] = r
    return result


# ## Average F1-score CESNA

# In[13]:


import os
import community

def calF1scoreWithEpsilonCESNA(dataname, folderdir, originalPartitionFile, Model = 'CAGM', threshold =0):
    elist = [0.0, 2.0, 3.0, 4.0, 5.0]
    #if dataname == 'epinions':
    #    elist = [6.0, 7.0, 8.0, 9.0]
        
    com_cesna = readCesnaPartition(originalPartitionFile)
    #gedge = readEpinionsGraph(originalPartitionFile)
    #partition_gedge = community.best_partition(gedge) 
    #com_cesna =  get_coms_from_partition(partition_gedge)
    
    result = dict([])
    for e in elist:
        prefix = '{}_partition_cesna_{}_'.format(dataname, e)
        r = []
        for file in os.listdir(folderdir):
            if file.startswith(prefix):
                print(file)
                partitionfile = '{}/{}'.format(folderdir, file)
                
                com_cesna_gen1 = readCesnaPartition(partitionfile)
                f1_1 = cal_final_f1(com_cesna, com_cesna_gen1,threshold)
                r.append(f1_1)
        result[e] = r
    return result



# ## community histograms

# In[44]:


import matplotlib
import matplotlib.pyplot as plt
import numpy as np
import matplotlib.font_manager as font_manager

CPGML =(0.18, 0.17, 0.17, 0.16)
TriCycleL = (0.04, 0.04, 0.04, 0.04)
DCSBML = (0.18, 0.17, 0.16, 0.17)

CPGMC = (0.25, 0.26, 0.25, 0.32)
TriCycleC = (0.20, 0.20, 0.20, 0.20)
DCSBMC = (0.26, 0.25, 0.25, 0.25)

fig, ax = plt.subplots(nrows =1, ncols= 2, figsize= (10, 4))
axis_font = {'fontname':'Arial', 'size':'21'}
font_prop = font_manager.FontProperties(size=19)
for i in range(2):
    ind = 0.5* np.arange(len(CPGML))
    print(ind)
    width = 0.15
    ax[i].set_ylabel('average F1-score',  **axis_font)
    ax[i].set_xticks(ind)
    ax[i].set_xticklabels((r'$\varepsilon=6.0$', r'$\varepsilon=7.0$', r'$\varepsilon=8.0$', 
                           r'$\varepsilon=9.0$'))
    
    ax[i].set_ylim(0, 0.45)
    ax[i].set_yticks(np.arange(0,0.5, 0.1))
   
    if i==0:
        ax[i].set_title("Louvain", **axis_font)
        rects1 = ax[i].bar(ind-width, CPGML, width, label = 'C-AGMDP')
        rects2 = ax[i].bar(ind, DCSBML, width, label = 'C-AGMDP-D')
        rects3 = ax[i].bar(ind+width, TriCycleL, width, label = 'AGMDP')
        
    #ax[0,i].set_title(r'$\varepsilon=$'+str(elist[i])+" (FB, PR, EP8K), " +  r'$\varepsilon=$' +str(elist[i]+4.0) + " (EP), Louvain", **axis_font)
 

    else:
        ax[i].set_title("CESNA", **axis_font)
        rects1 = ax[i].bar(ind-width, CPGMC, width, label = 'C-AGMDP')
        rects2 = ax[i].bar(ind, DCSBMC, width, label = 'C-AGMDP-D')
        rects3 = ax[i].bar(ind+width, TriCycleC, width, label = 'AGMDP')
    
    for label in (ax[i].get_xticklabels()):
        label.set_fontsize(18) 
    
    for label in (ax[i].get_yticklabels()):
        label.set_fontsize(18)
    ax[0].legend(prop = font_prop, labels = ['C-AGMDP', 'C-AGMDP-D', 'AGMDP'])
#fig.legend(prop = font_prop, labels = ['C-AGMDP', 'C-AGMDP-D', 'AGMDP'], ncol=3, fontsize='22',
#           bbox_to_anchor=(0.5, 1.1), loc='upper center')
fig.tight_layout()
plt.show()
fig.savefig("comparef1_EP6.pdf", bbox_inches='tight')


# In[3]:


import matplotlib
import matplotlib.pyplot as plt
import numpy as np
import matplotlib.font_manager as font_manager


#CPGML = {2.0:(0.32,0.11, 0.14,0.18), 3.0:(0.39, 0.25, 0.30,0.17), 4.0:(0.42, 0.30, 0.35,0.17), 5.0:(0.42, 0.34,0.40, 0.16)}
#TriCycleL = {2.0:(0.15, 0.08, 0.12,0.04), 3.0:(0.15, 0.08, 0.12,0.04), 4.0:(0.15, 0.08, 0.12,0.04), 5.0:(0.15, 0.08,0.12, 0.04)}
#DCSBML = {2.0:(0.15, 0.12, 0.13,0.18), 3.0:(0.15, 0.15, 0.21,0.17), 4.0:(0.16, 0.22, 0.24,0.16), 5.0:(0.16, 0.23, 0.34,0.17)}

#CPGMC = {2.0:(0.28,0.28,0.12, 0.25), 3.0:(0.32, 0.27, 0.19, 0.26), 4.0:(0.34, 0.32, 0.20, 0.25), 5.0:(0.35, 0.31, 0.22, 0.32)}
#TriCycleC = {2.0:(0.23, 0.21,0.12, 0.20), 3.0:(0.23, 0.21,0.13, 0.20), 4.0:(0.14, 0.21, 0.13, 0.20), 5.0:(0.24, 0.21, 0.13, 0.20)}
#DCSBMC = {2.0:(0.21, 0.19, 0.13, 0.26), 3.0:(0.24, 0.23, 0.16,0.25), 4.0:(0.27, 0.26,0.17, 0.25), 5.0:(0.28, 0.25, 0.20, 0.25)}


CPGML = {2.0:(0.32,0.11, 0.14,0.06), 3.0:(0.39, 0.25, 0.30,0.07), 4.0:(0.42, 0.30, 0.35,0.10), 5.0:(0.42, 0.34,0.40, 0.1)}
TriCycleL = {2.0:(0.15, 0.08, 0.12,0.05), 3.0:(0.15, 0.08, 0.12,0.05), 4.0:(0.15, 0.08, 0.12,0.05), 5.0:(0.15, 0.08,0.12, 0.05)}
DCSBML = {2.0:(0.15, 0.12, 0.13,0.05), 3.0:(0.15, 0.15, 0.21,0.05), 4.0:(0.16, 0.22, 0.24,0.09), 5.0:(0.16, 0.23, 0.34,0.10)}

CPGMC = {2.0:(0.28,0.28,0.12, 0.09), 3.0:(0.32, 0.27, 0.19, 0.09), 4.0:(0.34, 0.32, 0.20, 0.10), 5.0:(0.35, 0.31, 0.22, 0.11)}
TriCycleC = {2.0:(0.23, 0.21,0.12, 0.09), 3.0:(0.23, 0.21,0.13, 0.10), 4.0:(0.14, 0.21, 0.13, 0.11), 5.0:(0.24, 0.21, 0.13, 0.10)}
DCSBMC = {2.0:(0.21, 0.19, 0.13, 0.09), 3.0:(0.24, 0.23, 0.16,0.09), 4.0:(0.27, 0.26,0.17, 0.10), 5.0:(0.28, 0.25, 0.20, 0.10)}
fig, ax = plt.subplots(nrows =2, ncols= 4, figsize= (28, 8))
elist = [2.0, 3.0, 4.0, 5.0]
axis_font = {'fontname':'Arial', 'size':'21'}
font_prop = font_manager.FontProperties(size=20)
for i in range(4):
    ind = 0.5* np.arange(len(CPGML[elist[i]]))
    width = 0.15
    rects1 = ax[0,i].bar(ind-width, CPGML[elist[i]], width, label = 'C-AGMDP')
    rects2 = ax[0,i].bar(ind, DCSBML[elist[i]], width, label = 'C-AGMDP-D')
    rects3 = ax[0,i].bar(ind+width, TriCycleL[elist[i]], width, label = 'AGMDP')

    ax[0,i].set_ylabel('average F1-score',  **axis_font)
    #ax[0,i].set_title(r'$\varepsilon=$'+str(elist[i])+" (FB, PR, EP8K), " +  r'$\varepsilon=$' +str(elist[i]+4.0) + " (EP), Louvain", **axis_font)
    ax[0,i].set_title(r'$\varepsilon=$'+str(elist[i])+", Louvain", **axis_font)
    ax[0,i].set_xticks(ind)
    ax[0,i].set_xticklabels(('Petster', 'Facebook', 'Epinions8K', 'Epinions'))
    
    ax[0,i].set_ylim(0, 0.45)
    ax[0,i].set_yticks(np.arange(0,0.5, 0.1))

    for label in (ax[0,i].get_yticklabels()):
        label.set_fontsize(20)
    
    for label in (ax[0,i].get_xticklabels()):
        label.set_fontsize(17)

for i in range(4):
    ind = 0.5* np.arange(len(CPGMC[elist[i]]))
    width = 0.15
    rects1 = ax[1,i].bar(ind-width, CPGMC[elist[i]], width, label = 'C-AGMDP')
    rects2 = ax[1,i].bar(ind, DCSBMC[elist[i]], width, label = 'C-AGMDP-D')
    rects3 = ax[1,i].bar(ind+width, TriCycleC[elist[i]], width, label = 'AGMDP')

    ax[1,i].set_ylabel('average F1-score',  **axis_font)
    #ax[1,i].set_title(r'$\varepsilon=$'+str(elist[i])+" (FB, PR, EP8K), " +  r'$\varepsilon=$' +str(elist[i]+4.0) + " (EP), CESNA",
    ax[1,i].set_title(r'$\varepsilon=$'+str(elist[i])+ ", CESNA",**axis_font)
    ax[1,i].set_xticks(ind)
    ax[1,i].set_xticklabels(('Petster', 'Facebook', 'Epinions8K', 'Epinions'))
    ax[1,i].set_ylim(0, 0.5)
    ax[1,i].set_yticks(np.arange(0,0.5, 0.1))
    for label in (ax[1,i].get_xticklabels()):
        label.set_fontsize(18)
        
    for label in (ax[1,i].get_yticklabels()):
        label.set_fontsize(20)
fig.legend(prop = font_prop, labels = ['C-AGMDP', 'C-AGMDP-D', 'AGMDP'], ncol=3, fontsize='22',
           bbox_to_anchor=(0.5, 1.1), loc='upper center')
fig.tight_layout()
plt.show()
fig.savefig("compare_f1.pdf", bbox_inches='tight')

